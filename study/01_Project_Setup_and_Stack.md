# 1. 프론트엔드 프로젝트 생성 및 기술 스택 선정 이유

이 문서는 백엔드 개발자가 프론트엔드 프로젝트의 초기 구성과 기술 스택 선정 이유를 이해하기 위해 작성되었습니다.
**목표: 백엔드 개발자에서 프론트엔드까지 아우르는 풀스택 마스터로 성장하기**

---

## 1. 핵심 용어 정복 (Frontend 101)

프론트엔드 코드를 보기 전에 반드시 알아야 할 핵심 개념들입니다. 백엔드 개념과 매핑하여 설명합니다.

### 1.1. 컴포넌트 (Component)
*   **정의**: UI를 구성하는 레고 블록입니다. 버튼 하나, 입력창 하나, 혹은 페이지 전체가 하나의 컴포넌트가 될 수 있습니다.
*   **특징**: React에서는 **함수(Function)**로 만듭니다.
*   **백엔드 비유**: 하나의 **클래스(Class)**나 **메서드**와 비슷합니다. 입력을 받아 화면(HTML)을 리턴합니다.

### 1.2. Props (Properties)
*   **정의**: 부모 컴포넌트가 자식 컴포넌트에게 전달하는 **데이터**입니다. (읽기 전용)
*   **백엔드 비유**: 메서드의 **파라미터(Parameter)** 혹은 **DTO**입니다.
    ```tsx
    // 호출하는 쪽 (Parent)
    <Welcome name="Aslan" />

    // 정의하는 쪽 (Child)
    function Welcome(props) {
      return <h1>Hello, {props.name}</h1>;
    }
    ```

### 1.3. State (상태)
*   **정의**: 컴포넌트 내부에서 관리되는 **동적인 데이터**입니다. 이 값이 바뀌면 React는 자동으로 화면을 다시 그립니다(Re-render).
*   **백엔드 비유**: 객체의 **멤버 변수(Field)**와 비슷하지만, 값이 바뀔 때마다 `View`가 자동으로 업데이트된다는 점이 다릅니다.

### 1.4. 훅 (Hooks) 🔥 (중요)
*   **정의**: 함수형 컴포넌트에서 State(상태)나 생명주기(Lifecycle) 같은 React의 핵심 기능을 "갈고리(Hook)로 걸어서" 사용할 수 있게 해주는 함수들입니다. 모든 훅은 `use`로 시작합니다.
*   **등장 배경**: 예전에는 Class 컴포넌트를 써야만 상태 관리가 가능했는데, 너무 복잡했습니다. 이제는 함수형 컴포넌트에서도 훅을 통해 모든 기능을 쓸 수 있습니다.
*   **대표적인 훅**:
    *   `useState`: 메모장입니다. 값을 기억하고, 바꾸면 화면을 갱신합니다.
    *   `useEffect`: 타이밍 함수입니다. "화면이 처음 떴을 때", "특정 값이 바뀌었을 때" 실행할 로직을 넣습니다. (백엔드의 `@PostConstruct`나 이벤트 리스너와 유사)

### 1.5. 커스텀 훅 (Custom Hooks) 🚀 (고급)
*   **정의**: 개발자가 직접 만든 훅입니다. 여러 컴포넌트에서 반복되는 로직(상태 관리 + 기능)을 뽑아내어 재사용 가능한 함수로 만든 것입니다.
*   **백엔드 비유**: **Service Layer** 혹은 **Utility Class**로 로직을 추출하는 리팩토링 과정과 완벽히 동일합니다.
*   **예시**:
    *   상황: A 페이지에서도 유저 정보를 가져와야 하고, B 페이지에서도 유저 정보를 가져와야 함.
    *   해결: `useUser()`라는 커스텀 훅을 만들어서 로직을 한 곳에 모음.
    ```tsx
    // useUser.ts (커스텀 훅)
    function useUser() {
      const [user, setUser] = useState(null);
      // ... API 호출 로직 ...
      return user;
    }

    // Component.tsx
    function Profile() {
      const user = useUser(); // 한 줄로 끝!
      return <div>{user.name}</div>;
    }
    ```

---

## 2. 파일 확장자 구분 (.ts vs .js)

프로젝트를 보면 `.ts`, `.tsx`, `.js` 파일이 섞여 있습니다. 그 기준은 **"실행 환경"**과 **"목적"**입니다.

| 확장자 | 주 사용처 | 실행 주체 | 목적 |
| :--- | :--- | :--- | :--- |
| **.ts / .tsx** | `src/` 폴더 내부 | 브라우저 (변환 후) | **실제 애플리케이션 코드**. 타입 안정성이 필수적이므로 TypeScript를 사용합니다. <br> - `.ts`: 로직 파일 <br> - `.tsx`: React 컴포넌트 (JSX 포함) |
| **.js** | 프로젝트 루트 (설정 파일) | Node.js (빌드 도구) | **도구 설정 파일** (`tailwind.config.js` 등). 빌드 도구들이 기본적으로 JS 파일을 읽도록 설계되어 있으며, 복잡한 로직이 없어 굳이 컴파일이 필요한 TS를 쓰지 않는 경우가 많습니다. |

**결론**: `src` 폴더 안에서 우리가 짜는 코드는 무조건 **TypeScript(.ts, .tsx)**를 씁니다!

---

## 3. 기술 스택 선정 (Why?)

최신 프론트엔드 트렌드는 **"개발 생산성(DX)"**, **"타입 안정성"**, **"성능"**을 최우선으로 합니다.

### 3.1. React (UI 라이브러리)
*   **선정 이유**: 가장 방대한 생태계. 문제 해결이 쉽고 라이브러리가 풍부함.
*   **백엔드 비유**: **Spring Boot**. 표준이자 대세.

### 3.2. TypeScript (언어)
*   **선정 이유**: JavaScript에 정적 타입을 추가. 런타임 에러 방지.
*   **백엔드 비유**: **Java**. 타입이 명시되어야 안심이 되는 그 느낌.

### 3.3. Vite (빌드 도구)
*   **선정 이유**: 압도적으로 빠른 빌드 속도.
*   **백엔드 비유**: Gradle 데몬이 켜져 있어 빌드가 0.1초 만에 끝나는 쾌적함.

### 3.4. Tailwind CSS (스타일링)
*   **선정 이유**: CSS 파일 없이 HTML 클래스로 스타일링. 이름 짓기 고민 해결.
*   **코드 예시**: `<div className="bg-blue-500 text-white">`

### 3.5. TanStack Query (서버 상태 관리)
*   **선정 이유**: API 데이터 캐싱, 로딩, 에러 처리를 자동화.
*   **백엔드 비유**: **DB 캐싱 레이어**. `useEffect`로 직접 API를 호출하는 건 JDBC로 직접 쿼리 날리는 것만큼 구식입니다.

### 3.6. Zustand (전역 상태 관리)
*   **선정 이유**: Redux보다 훨씬 가볍고 쉬움.
*   **사용처**: 로그인 정보, 테마 등 앱 전체 공유 데이터.

---

## 4. 폴더 구조 설명

확장성을 고려하여 다음과 같이 폴더를 구성했습니다. (`src/` 내부)

*   **`api/`**: 백엔드 API 호출 함수 (Axios)
*   **`components/`**: 재사용 가능한 공통 UI (Button, Input)
*   **`features/`**: **핵심 비즈니스 로직**. 기능별(auth, lecture)로 묶음. (DDD의 도메인별 패키징과 유사)
*   **`hooks/`**: 전역 커스텀 훅 (Service 로직)
*   **`layouts/`**: 페이지 레이아웃 (Header, Sidebar)
*   **`pages/`**: 실제 라우팅되는 페이지 (Controller가 리턴하는 View)
*   **`stores/`**: 전역 상태 (Zustand)
*   **`types/`**: TypeScript 타입 정의 (DTO)
*   **`utils/`**: 유틸리티 함수
